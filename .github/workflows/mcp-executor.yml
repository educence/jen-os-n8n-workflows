# MCP Executor Workflow - Windows self-hosted runner with Git SSH
# Claude emits workflow_dispatch requests, runner executes with local secrets
# SECURITY: Command allowlist enforced before execution

name: MCP Executor

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action type: ssh_exec, file_read, status_check'
        required: true
        type: choice
        options:
          - ssh_exec
          - status_check
          - file_read
      target:
        description: 'Connection ID from registry (e.g., hetzner-main)'
        required: true
        default: 'hetzner-main'
      command:
        description: 'Command to execute (for ssh_exec) - must match allowlist'
        required: false
        default: 'echo "connected"'
      path:
        description: 'File path (for file_read) - must match allowlist'
        required: false

jobs:
  execute:
    runs-on: self-hosted
    timeout-minutes: 5
    
    steps:
      - name: Log Request
        shell: pwsh
        run: |
          $timestamp = Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ'
          Write-Host "========== MCP EXECUTOR LOG =========="
          Write-Host "Timestamp: $timestamp"
          Write-Host "Action: ${{ inputs.action }}"
          Write-Host "Target: ${{ inputs.target }}"
          Write-Host "Command: ${{ inputs.command }}"
          Write-Host "Path: ${{ inputs.path }}"
          Write-Host "Runner: $env:COMPUTERNAME"
          Write-Host "======================================="

      - name: Validate Command Allowlist
        if: inputs.action == 'ssh_exec'
        shell: pwsh
        run: |
          # SECURITY: Only these command patterns are allowed
          $allowlist = @(
            '^echo ',
            '^hostname$',
            '^uptime$',
            '^whoami$',
            '^pwd$',
            '^ls ',
            '^cat ',
            '^docker ps',
            '^docker stats',
            '^docker logs ',
            '^systemctl status ',
            '^systemctl restart n8n',
            '^curl -L .+cloudflared',
            '^dpkg -i cloudflared',
            '^cloudflared ',
            '^sudo dpkg -i cloudflared',
            '^sudo systemctl ',
            '^mkdir -p ',
            '^touch '
          )
          
          $command = "${{ inputs.command }}"
          $allowed = $false
          
          foreach ($pattern in $allowlist) {
            if ($command -match $pattern) {
              $allowed = $true
              Write-Host "Command matches allowlist pattern: $pattern"
              break
            }
          }
          
          if (-not $allowed) {
            Write-Error "SECURITY: Command not in allowlist: $command"
            Write-Error "Allowed patterns: $($allowlist -join ', ')"
            exit 1
          }
          
          Write-Host "Command validated: $command"

      - name: Validate Path Allowlist  
        if: inputs.action == 'file_read'
        shell: pwsh
        run: |
          # SECURITY: Only these path patterns are allowed
          $pathAllowlist = @(
            '^/home/jen/',
            '^/etc/n8n',
            '^/var/log/',
            '^\.n8n/',
            '^~/'
          )
          
          $filePath = "${{ inputs.path }}"
          $allowed = $false
          
          foreach ($pattern in $pathAllowlist) {
            if ($filePath -match $pattern) {
              $allowed = $true
              Write-Host "Path matches allowlist pattern: $pattern"
              break
            }
          }
          
          if (-not $allowed) {
            Write-Error "SECURITY: Path not in allowlist: $filePath"
            exit 1
          }

      - name: Resolve Connection
        id: resolve
        shell: pwsh
        run: |
          switch ("${{ inputs.target }}") {
            "hetzner-main" {
              "host=157.180.30.27" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "user=jen" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "key_path=$env:USERPROFILE\.ssh\id_ed25519" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            }
            default {
              Write-Error "Unknown target: ${{ inputs.target }}"
              exit 1
            }
          }
          
      - name: Verify SSH Key Exists
        shell: pwsh
        run: |
          $keyPath = "${{ steps.resolve.outputs.key_path }}"
          if (-not (Test-Path $keyPath)) {
            Write-Error "SSH key not found at $keyPath"
            exit 1
          }
          Write-Host "SSH key verified at $keyPath"
          
      - name: Execute SSH Command
        if: inputs.action == 'ssh_exec'
        shell: pwsh
        run: |
          $sshPath = "C:\Program Files\Git\usr\bin\ssh.exe"
          $keyPath = "${{ steps.resolve.outputs.key_path }}"
          $target = "${{ steps.resolve.outputs.user }}@${{ steps.resolve.outputs.host }}"
          $command = "${{ inputs.command }}"
          
          & $sshPath -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 -o BatchMode=yes -i $keyPath $target $command
              
      - name: Status Check
        if: inputs.action == 'status_check'
        shell: pwsh
        run: |
          $sshPath = "C:\Program Files\Git\usr\bin\ssh.exe"
          $keyPath = "${{ steps.resolve.outputs.key_path }}"
          $target = "${{ steps.resolve.outputs.user }}@${{ steps.resolve.outputs.host }}"
          
          Write-Host "Checking connection to ${{ inputs.target }}..."
          & $sshPath -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 -o BatchMode=yes -i $keyPath $target "hostname && uptime && docker ps --format 'table {{.Names}}\t{{.Status}}' 2>/dev/null || echo 'Docker not running'"
              
      - name: Read File
        if: inputs.action == 'file_read'
        shell: pwsh
        run: |
          $sshPath = "C:\Program Files\Git\usr\bin\ssh.exe"
          $keyPath = "${{ steps.resolve.outputs.key_path }}"
          $target = "${{ steps.resolve.outputs.user }}@${{ steps.resolve.outputs.host }}"
          $filePath = "${{ inputs.path }}"
          
          & $sshPath -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 -o BatchMode=yes -i $keyPath $target "cat '$filePath'"
